= README
:nofooter:
:source-highlighter: coderay
:icons: font
:toc: left

[WARNING]
====
This project is so, incredibly unfinished.
What's currently in this repo is very much a MVP.
There are no tests and barely any documentation (yet!).
====

== Introduction

=== One-Sentence Summary

Collagen is a program that takes as input a folder containing zero or more image files
(`.jpeg`, `.png`, etc.) and a JSON manifest file describing the layout of these images
along with SVG components such as shapes and text, and produces as output a single SVG
file with all assets embedded.

=== Rationale

There are several widely used image formats, perhaps the three best known of which are JPEG, PNG, and SVG.
JPEG and PNG are link:https://en.wikipedia.org/wiki/Raster_graphics[raster formats], which means they correspond to a rectangular grid of pixels.
On the other hand, SVG is a link:https://en.wikipedia.org/wiki/Vector_graphics[vector format], which means it describes perfectly precise curves that can be displayed with arbitrarily high precision.
These three formats are each optimized for a different use case:

- link:https://en.wikipedia.org/wiki/Jpeg[JPEG^] uses lossy compression that preserves visual quality on most "real-life" images -- images that contain smoothly-varying gradients -- but which produces link:https://en.wikipedia.org/wiki/Compression_artifact#Images[visible artifacts^] when used on other kinds of images, especially ones containing hard edges and/or text.
- link:https://en.wikipedia.org/wiki/Portable_Network_Graphics[PNG^] uses lossless compression that handles images with few distinct colors well, but requires an inordinate amount of space for storing images with many colors.
- link:https://en.wikipedia.org/wiki/Scalable_Vector_Graphics[SVG^] is a vector graphics format which can nevertheless contain embedded raster images; however, doing so requires base64 encoding the raster image.

Because each of these image formats is optimized for only a single use case, they cannot be easily combined.
For instance, overlaying text on a JPEG image will introduce compression artifacts that were not present in the original text, while overlaying a JPEG image on a PNG will cause the file size to balloon.

_Collagen_ -- from "collage" and "generate"footnote:[
	And because link:https://en.wikipedia.org/wiki/Collagen[collagen] is the protein that holds your body together.
	`s/protein/tool/;s/body/images/`
]
-- aims to fix this problem by packing all types of images, as well as vector shapes and text, into a single SVG file, the actual rendering of which is left to an SVG viewer application (which includes most web browsers).
This allows a user to combine several graphics into a single file that can be displayed as an image without compromising on visual quality or file size.footnote:[
	Technically base64 encoding data does increase its size by about a third.
	However, you don't need to pay this cost when transmitting the file; you can transmit the raw components and then use Collagen to encode them into an SVG on the receiving end.
	In other words, Collagen is akin to compression such as gunzip: it allows a smaller payload to be transmitted as long as the receiving end can turn it back into something useful.
]

== Using Collagen

The input to Collagen is a folder containing at the very least a `collagen.json` manifest file describing the layout of the resulting SVG.
If the manifest specifies any image files (by their path relative to the folder), then those image files must also be present at the expected path in the folder.
An input folder satisfying these criteria will be referred to as a _skeleton_.

=== A Basic Example

An example of a simple input-output pair is below.
Suppose you have the following simple skeleton at directory `example-01`:

[source,text]
----
example-01
├── collagen.json
└── images
    └── smiley.jpg
----

Where link:/examples/example-02/example-01/images/smiley.jpg[`images/smiley.jpg`] is the following image (whose native size is 380×380 pixels):

image::/examples/example-02/example-01/images/smiley.jpg[width=200px]

And where link:/examples/example-02/example-01/collagen.json[`collagen.json`] contains the following:

[source,json,indent=0,tabsize=2]
----
include::./examples/example-02/example-01/collagen.json[]
----

Then, running the following command:footnote:[
	At some point `cargo run --` will be replaced with an actual standalone executable `clgn`.
]

[source,bash]
----
cargo run -- -i example-01 -o example-01.svg
----

Will produce the following file, link:/examples/svgs/example-01.svg[`examples-01.svg`]:

image::/examples/svgs/example-01.svg[width=500]

If you zoom in, you'll see the smiley face's pixels.
But because the nose and speech bubble are SVG elements (i.e., vector graphics, not raster) they look nice and smooth and crisp even when zoomed in.
That's the whole point!
Perfectly precise vector graphics can coexist alongside raster graphics.
(This simple example shows just one image, but of course we could include arbitrarily many by simply adding more children of the form `{"image_path": <path>}`.)

=== A More Complicated Example

As we've seen, we can include raster images in skeletons; it would be silly if we couldn't also include other skeletons!
Nested skeletons can be included by adding a child of the form `{"clgn_path": <path>}`.
(Whereas a standalone skeleton gets turned into a `<svg>` tag, a nested skeleton will reside in a `<g>` tag.)
Let's include the above skeleton in another:

[source,text]
----
example-02
├── collagen.json
└── example-01
    ├── collagen.json
    └── images
        └── smiley.jpg
----

Where link:/examples/example-02/collagen.json[`example-02/collagen.json`] is below:

[source,json,indent=0,tabsize=2]
----
include::./examples/example-02/collagen.json[]
----

Here's the result (link:/examples/svgs/example-02.svg[link]) when you run `cargo run \-- -i example-02 -o example-02.svg`:

image::/examples/svgs/example-02.svg[width=300]

So, as far as Collagen is concerned, skeletons act more or less the same as raster images, in the sense that the path is sufficient to include them.
The only difference is that the path to a skeleton child is given by the key `clgn_path` instead of `image_path`.

== FAQ

[qanda]
Wait, so all this does is base64 encode images and put them in an SVG with other SVG elements?::
It adds some additional features, such as nesting of skeletons and the use of tag-wide variables and interpolation of these variables in attributes.
But yes, for the most part, all this project does is allow raster images to coexist with each other and with vector graphics.

Couldn't I just do the base64 encoding and create the SVG myself?::
Yes.
All Collagen does it automate this.

I want to put some text on a JPEG. What's so bad about just opening an image editor, adding the text, and pressing save?::
The text will look bad because
+
. It will no be longer an infinitely zoomable vector entity, but instead will have been rasterized, i.e., rendered onto a fixed pixel grid that is only finitely zoomable.
. JPEG in particular is not optimized for text, so artifacts will be visible (see link:https://commons.wikimedia.org/w/index.php?title=File:Jpeg-text-artifacts.gif&oldid=453916290[here]).

I'm ok with text being rasterized. This means I can convert my JPEG to PNG and avoid #2 above, right?::
Yes and no. While the text will look sort of ok (when not zoomed in), you now have the problem that your JPEG is being stored as a PNG.
Chances are that this will cause the resulting file size to explode because PNG is simply not meant to store the kind of images that JPEG is meant to store.
For instance, the JPEG below (link:https://commons.wikimedia.org/w/index.php?title=File:Planta62.jpg&oldid=424889773[source]) is 57KB, whereas the PNG is 434KB.
+
--
This JPEG weighs in at 57KB:::
+
image::/examples/pics/Planta62.jpg[width=300]


The equivalent PNG weighs in at 434KB:::
+
image::/examples/pics/Planta62.png[width=300]
--

But surely just placing black text on top of an all-white PNG is fine? Because it's stored losslessly?::
Sure, _if_ you don't mind your text being rasterized, i.e., not perfectly precise and infinitely zoomable.
The image below is black text on a white background.
+
image::/examples/pics/text_png.png[]
+
You don't have to zoom in very far to see the text get fuzzy.
In contrast, the text in the smiley-face image above (and, naturally, the text on this webpage) is perfectly precise and will retain all of its detail at arbitrary magnification.
